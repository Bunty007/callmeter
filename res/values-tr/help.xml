<?xml version="1.0" encoding="utf-8"?>
<!--
               Copyright (C) 2009-2012 Felix Bechstein
       -->
<!--
               This file is part of Call Meter 3G. This program is free software; you can
               redistribute it and/or modify it under the terms of the GNU General
               Public License as published by the Free Software Foundation; either
               version 3 of the License, or (at your option) any later version.
       -->
<!--
               This program is distributed in the hope that it will be useful, but
               WITHOUT ANY WARRANTY; without even the implied warranty of
               MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
               General Public License for more details. You should have received a
               copy of the GNU General Public License along with this program; If
               not, see <http://www.gnu.org/licenses/>.
       -->
<!--
               This file is generated automatically by ub0rlib/php.
               Visit http://ub0r.de/translate/cm3/tr/help.xml to edit the file.
       -->
<resources>
  <string name="help_title_" formatted="false" orig="Please read the following to understand the concept of &lt;b&gt;logs&lt;/b&gt;, &lt;b&gt;plans&lt;/b&gt; and &lt;b&gt;rules&lt;/b&gt;:">Estağfirullah. O halde f6ncelikle Memory Leak\'ler hususunda bir kae7 kelam emtkete fayda olabilir. Memory Leak\'ler hepimizin bildiği gibi yf6netemediğimiz hafıza taşmalarıdır. d6rneğin bir nesneyi create ettikten sonra ona referans veren değişkeni nil\'e eşitlemek, yada gf6sterdiği adresi değiştirmek artık hafızada ayrılmış olan bloğun asla serbest kalamaması anlamını taşır. Bir kae7 f6rnek vermek faydalı olabilir sanırım;var  b : TButton;begin  b := TButton.Create(Self);  ShowMessage(InttoStr(Integer(Pointer(b))));  b := TButton.Create(Self);  ShowMessage(InttoStr(Integer(Pointer(b))));end; Yukarıdaki kod f6rneğimizde 2 adet TButton nesnesi oluşturduk ve bu nesnelerin Owner\'ını Self olarak ayarladık. Bu durumda; program kapatılırken ilgili Button nesneleri Free edilebilecektir. Ama uygulamamız yaşam df6ngfcsfcnde iken iki nesnenin de Free edilebilmesi sf6z konusu değildir. İlk olarak oluşturulan Button nesnesi b değişkeni tarafından işaret ediliyor ancak hemen ardından b değişkeninin gf6sterdiği adres yeni bir button\'un create edilmesi ve b değişkenine atanması yolu ile kaybediliyor. Bu sebeple birinci oluşturulan Button programımız e7alışırken asla bir daha yok edilemez. İkinci button\'un create edilmesi ve b değişkenine adresinin atanmasından sonra ise procedure\'den e7ıkılıyor ve artık b değişkenine de erişilemiyor. Dolayısı ile ikinci button\'da yok edilemiyor. Gf6rfcldfcğfc fczere Memory Leak\'ler her daim oluşabilme ihtimalleri ile son derece dikkat edilesi programlama unsurlarıdır. Programımızın e7alışması sırasında oluşturduğumuz nesnelere, daha sonra o nesneleri Free edebilmek amacı ile ulaşamıyorsak hangi nedenle yada hangi yf6ntemle olursa olsun bunun adı Memory Leak\'tir. Şimdi gelelim Operator Overloading\'in oluşturacağı memory leak\'lere.. İster record\'larda kullanın isterseniz de sınıflarda kullanın, tfcm operator metodları class metodlardır. Ve class metodların ie7inden ilgili nesne instance\'ına ve o sınıf ie7indeki static değişken ve metod tanımlarına erişemezsiniz. Bu gibi bir durumda, sınıflara uygulanacak operator overloading\'de mecburen geriye yeni bir instance df6ndfcrmek durumunda kalırsınız. d6rneğin;type  TIntegerClass = class  private    fData : Integer;  public    class operator Add(a: TIntegerClass; b: Integer): TIntegerClass; // Delphi\'de sınıflarda operator overloading olsa idi tanımı bu şekilde olurdu.  end;class TIntegerClass.operator Add(a: TIntegerClass; b: Integer): TIntegerClass;begin  // Bu kod bloğunda Self kullanamazsınız. Result bir sınıf tfcrfc olduğu ie7in, mecburen bir instance\'ını oluşturmak durumunda kalırdınız.  Result := TIntegerClass.Create;  Result.fData := a.fData + b;end;Şimdi gelelim kullanımına;var  aIntClass : TIntegerClass;begin  aIntClass := TIntegerClass.Create;  aIntClass.fData := 100;  aIntClass := aIntClass + 100; // İşte tam bu noktada aIntClass değişkeninin gf6sterdiği memory adresi bir başka yeri gf6stermeye başlar ve f6nceki nesne artık temizlenmek fczere erişelemez duruma gee7er.(fDatası 100 olan nesne artık temizlenemeyecektir.)  aIntClass := aIntClass + 150; // Burada da ikinci oluşturduğumuz yani fDatası 200 olan nesne artık erişelemez duruma gelir.end; Yukarıda gf6rdfcğfcmfcz gibi, sınıflarda olabilecek operator overloading sfcrekli bir şekilde memory Leak\'lerin artmasına neden olur. Buna engel olmanın tek yolu(tabii sınıflarda operator overloading olsa idi), sınıfların herhangi bir interface\'i implemente etmesi yada derleyicinin GC gibi bir e7f6p toplayıcıya sahip olması olurdu. C++ dilini pek iyi bilmem, siz orada sınıflarda operator overloading var diyorsanız vardır. Bu konuda iddia sahibi olacak kadar bilgili değilim, le2kin programlamanın mantığı gereği; ya otomatik temizleme mekanizmasına sahip olmalı, interface implemente ediyor olmalı yada daha da garibi bir sınıf metodu ie7inden nesne verilerine ve metodlarına ulaşabiliyor olmalıdır.Umarım şimdi ortak bir noktada buluşabilmek adına yeterince ae7ık izah edebilmişimdir.</string>
  <string name="help_import_" formatted="false" orig="A good starting point are some preconfigured rule sets available on the website. Just import them via import menu and play around.">Web sitesinde önceden hazırlanmış bazı kural setleri bulunmaktadır. Bunlar iyi bir başlangıç noktası olabilir. İçe aktarma menüsünü kullanarak bunları içe aktarın ve inceleyin.</string>
  <string name="help_export_" formatted="false" orig="If you managed to set up a common plan for your country, do not hesitate to export your rule set to me by mail. I will put it on the website to make it available for all the users.">Ülkeniz için genel bir paket oluşturmayı başardıysanız lütfen bu kural setini bana e-posta yoluyla gönderin. Göndereceğiniz kural setlerini diğer kullanıcılar için web sitesinde yayınlayacağım.</string>
  <string name="help_logs_plans_rules_" formatted="false" orig="There are three kinds of data structures:">Üç çeşit veri yapısı mevcuttur:</string>
  <string name="help_logs_" formatted="false" orig="&lt;b&gt;Logs&lt;/b&gt; to save informations about your calls, messages and traffic statistics."><b>Loglar</b>: görüşme, mesajlar ve data istatistiklerinizle ilgili bilgileri saklamak için.</string>
  <string name="help_plans_" formatted="false" orig="&lt;b&gt;Plans&lt;/b&gt; to describe all kinds of aspects of your bill."><b>Paketler</b>: faturanızla ilgili tüm bilgilerin tanımlanması için.</string>
  <string name="help_rules_" formatted="false" orig="&lt;b&gt;Rules&lt;/b&gt; to match the &lt;b&gt;logs&lt;/b&gt; and move them to a particular &lt;b&gt;plan&lt;/b&gt;."><b>Kurallar</b>: <b>log</b>larla ilişkilendirmek ve bunları belirli bir <b>paket</b> içine yerleştirmek için.</string>
  <string name="help_plans_detail0_" formatted="false" orig="You can add or delete &lt;b&gt;plans&lt;/b&gt; just as you want. You can set the order by dragging them around with the handle on the right of the list view."><b>Paketleri</b> istediğiniz gibi ekleyebilir ve silebilirsiniz. Liste görünümünde sağda bulunan tutacağı kullanıp sürükleyerek sıralarını değiştirebilirsiniz.</string>
  <string name="help_plans_detail1_" formatted="false" orig="To edit a &lt;b&gt;plan&lt;/b&gt;, you just need to click it. At the next screen, you can set all kind of settings. There are a few, most users won\'t need. But some do. A short help for each setting is displayed in this view. Most settings you do not understand are not used in your country. Just leave them as they are. ;)">Bir <b>pakedin</b> ayarlarını değiştirmek için üzerine tıklamanız yeterlidir. Bir sonraki ekranda tüm ayarları değiştirebilirsiniz. Bazı ayarlar birçok kullanıcı tarafından kullanılmayacaktır. Ancak birçoğu kullanılabilir. Bu görünümde her bir ayar için kısa bir yardım metni görüntülenir. Anlam veremediğiniz ayarların birçoğu sizin ülkenizde kullanılmayan ayarlardır. Bunları olduğu gibi bırakın. ;)</string>
  <string name="help_plans_merge_" formatted="false" orig="You can merge &lt;b&gt;plans&lt;/b&gt; to aggregate their &lt;b&gt;log items&lt;/b&gt; to a combined cost and limit."><b>Paketleri</b>, <b>loglarının</b> toplam ücret ve limitlerini elde etmek üzere birleştirebilirsiniz.</string>
  <string name="help_rules_detail0_" formatted="false" orig="Edit the &lt;b&gt;rules&lt;/b&gt; in the same way. Each &lt;b&gt;rule&lt;/b&gt; does match some &lt;b&gt;log items&lt;/b&gt; and move them to a &lt;b&gt;plan&lt;/b&gt; in which the &lt;b&gt;logs&lt;/b&gt; should be billed in.">Aynı şekilde <b>kuralları</b> da ayarlayabilirsiniz. Her bir <b>kural</b> bazı <b>loglara</b> karşılık gelir. Bunları, <b>logların</b> ücretlendirilmesini istediğiniz bir <b>planın</b> içine taşıyın.</string>
  <string name="help_rules_detail1_" formatted="false" orig="But keep in mind, that order is important for &lt;b&gt;rules&lt;/b&gt;:">Ancak unutmayın ki, <b>kurallar</b> için sıra önemlidir:</string>
  <string name="help_rules_detail2_" formatted="false" orig="&lt;b&gt;Logs&lt;/b&gt; are matched &lt;b&gt;top-down&lt;/b&gt;, means: the first &lt;b&gt;rule&lt;/b&gt; that matches will stop processing of this particular &lt;b&gt;log item&lt;/b&gt;."><b>Kurallar</b> <b>yukarıdan aşağıya</b> doğru ilişkilendirilirler. Yani, yukarıdan itibaren ilişkilendirilen ilk <b>kural</b>, ilgili <b>logun</b> işlenmesini durduracaktır.</string>
  <string name="help_rules_detail3_" formatted="false" orig="E.g.: If you match all calls to 0800% numbers to a \&quot;free\&quot; &lt;b&gt;plan&lt;/b&gt; with the first &lt;b&gt;rule&lt;/b&gt;, there is no need to exclude these numbers in the second.">Örnek: Eğer 0800% ile başlayan tüm aramaları "ücretsiz" bir <b>paket</b> içinde ilk <b>kural</b> ile ilişkilendirirseniz bu numaraları ikinci bir <b>kuralda</b> hariç tutmanıza gerek yoktur.</string>
</resources>
